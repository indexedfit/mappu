<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Design‑Style Satellite Map</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://unpkg.com/maplibre-gl@3.3.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,body{margin:0;height:100%;overflow:hidden;-webkit-user-select:none;user-select:none}
    #map{position:absolute;inset:0}
    #selection{position:absolute;border:1px dashed #4a90e2;background:rgba(74,144,226,.12);pointer-events:none;display:none;z-index:10}
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="selection"></div>

  <script src="https://unpkg.com/maplibre-gl@3.3.1/dist/maplibre-gl.js"></script>
  <script>
    /* =====================
       Tunable constants (mobile + desktop)
       ===================== */
    const PAN_SENSITIVITY        = 1.25; // >1 pans farther per scroll pixel (desktop wheel + mobile 1‑finger)
    const WHEEL_ZOOM_DIVISOR     = 80;   // smaller ⇒ faster pinch‑to‑zoom on trackpads
    const PINCH_ZOOM_THRESHOLD   = 0.03; // 3‑% change before we zoom
    const LONG_PRESS_MS          = 350;  // hold this long (ms) to start rectangle on touch
    const LONG_PRESS_TOLERANCE   = 6;    // px you can wiggle before long‑press cancels

    /* === 1. Map === */
    const map = new maplibregl.Map({
      container: "map",
      style: {
        version: 8,
        sources: {
          sat: {
            type: "raster",
            tiles: [
              "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
            ],
            tileSize: 256,
            attribution: "Tiles © Esri & contributors"
          }
        },
        layers: [{ id: "sat", type: "raster", source: "sat" }]
      },
      center: [0, 20],
      zoom: 3,
      attributionControl: true
    });

    /* Disable MapLibre built‑ins; custom Figma‑style handlers below */
    map.dragPan.disable();
    map.touchZoomRotate.disable();
    map.doubleClickZoom.enable();

    /* === 2. Selection rectangle (shared) === */
    const selBox  = document.getElementById("selection");
    const canvas  = map.getCanvas();
    let selecting = false, sx = 0, sy = 0;
    const beginSelection = (x, y) => {
      selecting = true;
      sx = x; sy = y;
      Object.assign(selBox.style, { left: sx + "px", top: sy + "px", width: 0, height: 0, display: "block" });
    };
    const updateSelection = (x, y) => {
      const left = Math.min(x, sx);
      const top  = Math.min(y, sy);
      Object.assign(selBox.style, {
        left:   left + "px",
        top:    top  + "px",
        width:  Math.abs(x - sx) + "px",
        height: Math.abs(y - sy) + "px"
      });
    };
    const finishSelection = () => {
      if (!selecting) return;
      selecting = false;
      selBox.style.display = "none";
      const r = selBox.getBoundingClientRect();
      if (!r.width || !r.height) return; // tap only
      const nw = map.unproject([r.left,  r.top   ]);
      const se = map.unproject([r.right, r.bottom]);
      console.log("Selected bounds", { north: nw.lat, west: nw.lng, south: se.lat, east: se.lng });
    };

    /* === 3. Desktop: mouse rectangle + trackpad wheel === */
    canvas.addEventListener("mousedown", e => {
      if (e.button) return; // left button only
      beginSelection(e.clientX, e.clientY);
      e.preventDefault();
    });
    window.addEventListener("mousemove", e => selecting && updateSelection(e.clientX, e.clientY));
    window.addEventListener("mouseup", finishSelection);

    /* Trackpad wheel for pan / zoom */
    map.getCanvasContainer().addEventListener("wheel", e => {
      const isPinch = e.ctrlKey || e.metaKey; // macOS trackpad pinch sets these
      if (isPinch) {
        const zoomDelta = -e.deltaY / WHEEL_ZOOM_DIVISOR;
        map.zoomTo(map.getZoom() + zoomDelta, { around: map.unproject([e.clientX, e.clientY]), animate: false });
      } else {
        map.panBy([ e.deltaX * PAN_SENSITIVITY, e.deltaY * PAN_SENSITIVITY ], { animate: false });
      }
      e.preventDefault();
    }, { passive: false });

    /* === 4. Mobile / touch: 1‑finger pan, 2‑finger pinch+pan, long‑press rectangle === */
    const container   = map.getCanvasContainer();
    const touches     = new Map();
    let prevCenter, prevDist, prevSingle;
    let longPressTimer = null;

    const midpoint = (a, b) => ({ x: (a.clientX + b.clientX) / 2, y: (a.clientY + b.clientY) / 2 });
    const distance = (a, b) => Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);

    const clearLongPress = () => { if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; } };

    container.addEventListener("pointerdown", e => {
      if (e.pointerType !== "touch") return;
      touches.set(e.pointerId, e);
      container.setPointerCapture(e.pointerId);

      if (touches.size === 1) {
        prevSingle = e;
        longPressTimer = setTimeout(() => {
          beginSelection(e.clientX, e.clientY);
        }, LONG_PRESS_MS);
      } else if (touches.size === 2) {
        clearLongPress();
        const [p1, p2] = [...touches.values()];
        prevCenter = midpoint(p1, p2);
        prevDist   = distance(p1, p2);
      }
    }, { passive: false });

    container.addEventListener("pointermove", e => {
      if (!touches.has(e.pointerId)) return;
      touches.set(e.pointerId, e);

      if (touches.size === 1 && !selecting) {
        // 1‑finger pan (cancel long‑press if moved too far)
        if (Math.abs(e.clientX - prevSingle.clientX) > LONG_PRESS_TOLERANCE || Math.abs(e.clientY - prevSingle.clientY) > LONG_PRESS_TOLERANCE) {
          clearLongPress();
        }
        map.panBy([ prevSingle.clientX - e.clientX, prevSingle.clientY - e.clientY ], { animate: false });
        prevSingle = e;
      }
      else if (touches.size === 1 && selecting) {
        updateSelection(e.clientX, e.clientY);
      }
      else if (touches.size === 2) {
        // 2‑finger pinch+pan
        clearLongPress();
        const [p1, p2] = [...touches.values()];
        const center = midpoint(p1, p2);
        const dist   = distance(p1, p2);

        // Pan
        map.panBy([ prevCenter.x - center.x, prevCenter.y - center.y ], { animate: false });
        prevCenter = center;

        // Zoom
        const scale = dist / prevDist;
        if (Math.abs(scale - 1) > PINCH_ZOOM_THRESHOLD) {
          map.zoomTo(map.getZoom() + Math.log2(scale), { around: map.unproject([center.x, center.y]), animate: false });
          prevDist = dist;
        }
      }
    }, { passive: false });

    ["pointerup", "pointercancel", "pointerleave"].forEach(ev => container.addEventListener(ev, e => {
      touches.delete(e.pointerId);
      if (touches.size === 0) {
        clearLongPress();
        prevSingle = undefined;
        finishSelection();
      }
      if (touches.size < 2) {
        prevCenter = prevDist = undefined;
      }
    }));

    /* Prevent default context‑menu like Figma */
    canvas.addEventListener("contextmenu", e => e.preventDefault());
  </script>
</body>
</html>

